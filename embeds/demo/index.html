<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random embed demo with a 3d geometry</title>
    <style>
        body { margin: 0; }
        #container {
            width: 100%;
            max-height: 75vh;
            height: 75vh;
        }
        .label {
            color: #FFF;
            font-family: sans-serif;
            padding: 2px;
            background: rgba(0, 0, 0, 0.6);
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, labelRenderer, mesh;

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            const container = document.getElementById('container');
            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Label Renderer
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(container.clientWidth, container.clientHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            container.appendChild(labelRenderer.domElement);

            // Geometry
            const geometries = [
                new THREE.BoxGeometry(2, 2, 2),
                new THREE.SphereGeometry(1.5, 32, 32),
                new THREE.DodecahedronGeometry(1.5),
                new THREE.IcosahedronGeometry(1.5),
                new THREE.OctahedronGeometry(1.5),
                new THREE.TetrahedronGeometry(1.5),
                new THREE.TorusGeometry(1, 0.4, 16, 100),
                new THREE.TorusKnotGeometry(1, 0.4, 100, 16)
            ];
            const geometry = geometries[Math.floor(Math.random() * geometries.length)];

            // Material
            const material = new THREE.MeshNormalMaterial();

            // Mesh
            mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Labels
            const vertices = geometry.attributes.position;
            const normals = geometry.attributes.normal;
            const vertex = new THREE.Vector3();
            const normal = new THREE.Vector3();
            const addedLabels = new Set();
            let labelCount = 0;

            for (let i = 0; i < vertices.count; i++) {
                if (labelCount >= 360) {
                    break;
                }
                vertex.fromBufferAttribute(vertices, i);
                const key = vertex.toArray().join(',');
                if (!addedLabels.has(key)) {
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'label';
                    labelDiv.textContent = `V${i}`;
                    const label = new CSS2DObject(labelDiv);
                    label.position.copy(vertex);

                    if (normals) {
                        normal.fromBufferAttribute(normals, i);
                        label.userData.normal = normal.clone();
                    }

                    mesh.add(label);
                    addedLabels.add(key);
                    labelCount++;
                }
            }


            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Set initial size

            // Animation
            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            labelRenderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Slow rotation
            mesh.rotation.x += 0.001;
            mesh.rotation.y += 0.001;

            // Update matrix world
            mesh.updateMatrixWorld();

            // Update label visibility
            const cameraPosition = new THREE.Vector3();
            camera.getWorldPosition(cameraPosition);

            mesh.children.forEach(child => {
                if (child instanceof CSS2DObject && child.userData.normal) {
                    const label = child;
                    const worldPosition = new THREE.Vector3();
                    label.getWorldPosition(worldPosition);

                    const worldNormal = label.userData.normal.clone().applyMatrix3(mesh.normalMatrix).normalize();
                    
                    const toCamera = cameraPosition.clone().sub(worldPosition).normalize();
                    
                    const dot = worldNormal.dot(toCamera);
                    
                    label.visible = dot > 0;
                }
            });

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
